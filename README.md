# lab5[отчет5.md](https://github.com/user-attachments/files/23841248/5.md)
# Рязанова Кристина ИТ-7,8 Лабораторная №5

***

# Задание 1
## Задача 1
### Текст задачи
В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка числителя и установка знаменателя.
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного значения.
Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими особенностями:
• Имеет числитель: целое число
• Имеет знаменатель: целое число
• Дробь может быть создана с указанием числителя и знаменателя
• Может вернуть строковое представление вида “числитель/знаменатель”
• Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может быть отрицательным.
• Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби
считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя
#### Алгоритм решения
Сначала создается интерфейс FractionInterface с методами для получения вещественного значения и установки числителя/знаменателя. 
Затем реализуется базовый класс Fraction, который хранит числитель и знаменатель, проверяет корректность данных и нормализует знаки, обеспечивая неотрицательный знаменатель. Класс переопределяет методы equals(), hashCode() и toString() для корректной работы с объектами. 
Наследник CachedFraction добавляет кэширование вещественного значения - при первом вызове getValue() результат сохраняется и переиспользуется, а при изменении числителя или знаменателя кэш сбрасывается. Это обеспечивает оптимальную производительность при многократных обращениях к значению дроби.

<img width="352" height="438" alt="image" src="https://github.com/user-attachments/assets/21437af0-0d14-48da-8f77-c4e644fada3a" />

***

# Задание 2
## Задача 1
### Текст задачи
Количество мяуканий.
Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из задачи 2.5.4.
Необходимо таким образом передать кота в указанный метод, что бы после окончания его работы
узнать сколько раз мяукал кот за время его работы. На рисунке показан пример работы. Перед вызовом
метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы выводим
количество мяуканий на экран. Кота изменять нельзя.
Если раннее в вашем варианте не было Кота, то создайте
1. сущность Кот, которая описывается следующим образом:
• Имеет Имя (строка)
• Для создания необходимо указать имя кота.
• Может быть приведен к текстовой форме вида: “кот: Имя”
• Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”,
вызвать мяуканье можно без параметров.
2. интерфейс Мяуканье: разработайте метод, который принимает набор объектов способных
мяукать и вызывает мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со
следующей сигнатурой:
public void meow();
#### Алгоритм решения
Создаем декоратор MeowCounter, который оборачивает любой объект Meowable и добавляет функциональность подсчета мяуканий. 
При вызове метода meow() счетчик увеличивается на 1, после чего вызывается оригинальный метод мяукания. 
Для подсчета мяуканий конкретного кота оборачиваем его в MeowCounter перед передачей в метод makeAllMeow. 
После выполнения метода получаем количество мяуканий через getCount(), не изменяя исходный класс Cat.
Декоратор реализует тот же интерфейс Meowable, что позволяет прозрачно использовать его вместо оригинального объекта.

<img width="337" height="214" alt="image" src="https://github.com/user-attachments/assets/df187a02-50d8-4539-ae16-3a699c37eb26" />

***

# Задание 3
## Задача 10
### Текст задачи
Оставить в списке только первые вхождения одинаковых элементов.
#### Алгоритм решения
Создаем список unique для хранения результата и множество seen для отслеживания уже встреченных элементов. 
Проходим по всем элементам исходного списка и для каждого элемента пытаемся добавить его в множество seen. 
Метод add() возвращает true только если элемента еще не было в множестве, что означает его первое вхождение. 
В этом случае добавляем элемент в результирующий список unique. 
Таким образом сохраняются только первые вхождения каждого уникального элемента в порядке их появления в исходном списке

<img width="586" height="100" alt="image" src="https://github.com/user-attachments/assets/97767bff-6125-4d5c-9afa-7f95cd30ee09" />

***

# Задание 4
## Задача 10
### Текст задачи
В соревнованиях по многоборью (из M видов спорта) участвуют N спортсменов (N< 1000) .На
вход программе в первой строке подается число спортсменов N, во второй – число видов спорта
M. В каждой из последующих N строк находится информация в следующем формате:
<Фамилия><Имя><Баллы>
где <Фамилия> – строка, состоящая не более, чем из 20 символов без пробелов, <Имя> – строка,
состоящая не более, чем из 12 символов без пробелов, <Баллы> –Mцелых чисел, обозначающие
количество баллов, набранных спортсменом в каждом из видов многоборья.
<Фамилия> и <Имя>, <Имя> и <Баллы>, а также отдельные числа в поле <Баллы>разделены
ровно одним пробелом. Пример входных строк:
3
4
Иванов Сергей 100 30 78 13
Петров Антон 90 16 98 14
Сидоров Юрий 100 70 30 21
Программа должна выводить результирующую таблицу, содержащую список спортсменов,
отсортированный по убыванию суммы баллов, набранные суммы и занятые места.
В данном случае программа должна вывести
Иванов Сергей 221 1
Сидоров Юрий 221 1
Петров Антон 218 2
#### Алгоритм решения
Читаем из файла количество участников N и видов спорта M. Для каждого спортсмена разбираем строку, извлекаем фамилию, имя и баллы по каждому виду спорта. Суммируем все баллы спортсмена для получения общей суммы. Используем TreeMap с обратным порядком сортировки для автоматического упорядочивания участников по убыванию суммы баллов. Для обработки одинаковых результатов сохраняем список спортсменов с одинаковой суммой баллов в одном элементе мапы. При формировании результатов присваиваем места: участники с одинаковой суммой получают одинаковое место, а следующий участник получает место с учетом количества предыдущих спортсменов.

<img width="316" height="147" alt="image" src="https://github.com/user-attachments/assets/ec64f484-ecdf-4f59-826f-e7f9143bae5b" />

***

# Задание 5
## Задача 6
### Текст задачи
Файл содержит текст на русском языке. Напечатать в символы, которые встречаются хотя бы
однажды в словах с чётными номерами (нумерацию вести с 1)
#### Алгоритм решения
Читаем текст из файла по словам, используя Scanner. Для каждого слова определяем его номер в тексте (нумерация с 1). 
Если номер слова четный, обрабатываем все символы этого слова. Для каждого символа проверяем, является ли он русской буквой 
(в диапазонах 'А'-'Я' и 'а'-'я'). Найденные русские буквы добавляем в множество в нижнем регистре для обеспечения уникальности. 
После обработки всех четных слов выводим собранные уникальные русские символы. Множество автоматически устраняет дубликаты, оставляя только различные буквы.

<img width="556" height="95" alt="image" src="https://github.com/user-attachments/assets/6e9fde83-2396-4561-8d7d-a4ae96ac470d" />

***

# Задание 6
## Задача 1
### Текст задачи
Напечатать в обратном порядке элементы непустой очереди L
#### Алгоритм решения
Создаем очередь LinkedList и заполняем ее числами из введенной строки. Для вывода элементов в обратном порядке используем специальный итератор descendingIterator(), который предоставляет элементы в порядке от конца к началу. Проходим по всем элементам через этот итератор и выводим их на экран. Таким образом достигается обратный порядок вывода без изменения исходной очереди.

<img width="529" height="91" alt="image" src="https://github.com/user-attachments/assets/d278f485-6948-49df-8e96-c5c567c24df8" />

***

## Задание 7
### Задача 1
### Текст задачи
Необходимо написать стрим:
Дан набор объектов типа Point, необходимо взять все Point в разных координатах, убрать с
одинаковыми X,Y, отсортировать по X, отрицательные Y сделать положительными и собрать это
все в ломаную (объект типа Polyline)
Если раннее в вашем варианте не было задание с классом Point и Polyline, то написать их:
1. класс Point:
• Координата Х: число.
• Координата Y: число.
• Может возвращать текстовое представление вида “{X;Y}”.
2. класс Line (Линия), расположенная на двумерной плоскости, которая описывается:
• Координата начала: Точка
• Координата конца: Точка
• Может возвращать текстовое представление вида “Линия от {X1;Y1} до {X2;Y2}”
3. класс Polyline (Ломаная), которая будет представлять собой ломаную линию. Ломаная
линия представляет собой набор следующих характеристик:
• Имеет массив Точек, через которые линия проходит.
• Может быть приведена к строковой форме вида “Линия [Т1,T2,…,TN]”, где TN – это
результат приведения к строке Точки с номером N
#### Алгоритм решения
Создаем поток из массива точек и применяем цепочку операций: сначала удаляем дубликаты с одинаковыми координатами через distinct(), затем преобразуем каждую точку, делая координату Y положительной через Math.abs(), после чего сортируем точки по возрастанию координаты X. 
Полученную последовательность уникальных точек собираем в массив и создаем из него объект Polyline, представляющий ломаную линию

<img width="674" height="77" alt="image" src="https://github.com/user-attachments/assets/66544586-839b-4839-8c0e-59ad6e41ff9f" />

***

## Задание 7
### Задача 2
### Текст задачи
Дан текстовый файл со строками, содержащими имя человека и его номер в следующей форме:
Вася:5
Петя:3
Аня:5
Номера людей могут повторяться. У каких-то людей может не быть номера.
Необходимо написать стрим выполняющую следующее:
читаются все люди из файла, все имена приводится к нижнему регистру, но с первой буквой в
верхнем регистре, убираем из перечня всех людей без номеров, а имена оставшихся группируются
по их номеру:
[5:[Вася, Аня], 3:[Петя]]
#### Алгоритм решения
Читаем все строки из файла и разбиваем каждую на части по разделителю ":". Фильтруем строки, оставляя только те, где есть номер 
(вторая часть не пустая). Затем группируем данные по номеру (приводя его к целому числу), а имена обрабатываем: приводим к нижнему регистру и делаем первую букву заглавной. В результате получаем карту, где ключи - номера, а значения - списки имен людей с этими номерами.
<img width="632" height="79" alt="image" src="https://github.com/user-attachments/assets/8521a7d8-647f-4eb5-8992-d5acef57f7bd" />
